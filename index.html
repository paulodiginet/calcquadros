<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Calculadora de Preços 2026</title>
  <style>
    :root {
      --bg:#0b0f14; --card:#121826; --muted:#9aa4b2; --text:#e6eaf0;
      --accent:#4f8cff; --danger:#ff5d5d; --ok:#5dff9c;
      --border:rgba(255,255,255,.08);
    }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--text); }
    .wrap { max-width:860px; margin:0 auto; padding:18px; }
    h1 { font-size:18px; margin:0 0 10px; font-weight:700; }
    .card { background:var(--card); border:1px solid var(--border); border-radius:16px; padding:14px; box-shadow:0 10px 30px rgba(0,0,0,.25); }
    .grid { display:grid; grid-template-columns: repeat(12, 1fr); gap:10px; }
    label { font-size:12px; color:var(--muted); display:block; margin-bottom:6px; }
    input, select {
      width:100%; box-sizing:border-box; padding:12px 10px; border-radius:12px;
      border:1px solid var(--border); background:#0f1522; color:var(--text);
      outline:none;
    }
    input:focus, select:focus { border-color: rgba(79,140,255,.55); }
    .col-6 { grid-column: span 6; }
    .col-4 { grid-column: span 4; }
    .col-12 { grid-column: span 12; }
    .btn {
      cursor:pointer; border:none; border-radius:12px; padding:12px 12px;
      background:var(--accent); color:white; font-weight:700; width:100%;
    }
    .btn:active { transform: translateY(1px); }
    .btn.secondary { background: rgba(255,255,255,.08); color: var(--text); border:1px solid var(--border); font-weight:800; }
    .btn.secondary:hover { border-color: rgba(255,255,255,.16); }
    .resumo { margin-top:10px; border:1px solid var(--border); border-radius:14px; padding:10px 12px; background: rgba(255,255,255,.02); }

    .brandWrap { display:flex; justify-content:center; align-items:center; margin: 2px 0 10px; }
    .brandWrap img { max-width: 260px; width: 60%; height: auto; opacity: .95; }

    .rline { display:flex; justify-content:space-between; gap:10px; padding:6px 0; }
    .rline span { color: var(--muted); font-size:12px; }
    .rline b { font-size:14px; }
    .rline.total b { font-size:16px; }
    .stamp { margin-top:8px; text-align:center; font-size:12px; color: var(--muted); }
    .copyHint { margin-top:8px; font-size:12px; color: var(--muted); }

    .meta { font-size:12px; color:var(--muted); line-height:1.35; }
    .pill {
      display:inline-block; padding:6px 10px; border-radius:999px; font-size:12px;
      border:1px solid var(--border); background:rgba(255,255,255,.03); color:var(--muted);
    }
    .row { display:flex; flex-wrap:wrap; gap:8px; align-items:center; }
    .out {
      font-size:28px; font-weight:800; letter-spacing:-.02em; margin:6px 0 8px;
    }
    .warn { color: var(--danger); font-weight:700; }
    .good { color: var(--ok); font-weight:700; }
    .hr { height:1px; background:var(--border); margin:12px 0; }
    @media (max-width: 640px) {
      .col-6, .col-4 { grid-column: span 12; }
      .out { font-size:26px; }
    }
  
    .brandHeader{display:flex;justify-content:center;align-items:center;margin:10px 0 6px;}
    #brandLogo{max-width:260px;width:60%;height:auto;filter:drop-shadow(0 2px 8px rgba(0,0,0,.35));}

.logo-topo {
  display: flex;
  justify-content: center;
  margin: 12px 0 10px;
}
.logo-topo img {
  width: 60%;
  max-width: 260px;
  height: auto;
}
.titulo {
  text-align: center;
}


    .brandHeaderTop{margin:14px 0 10px;}
    .wrap > h1{ text-align:center; }


/* FIX DEFINITIVO TAMANHO LOGO */
.logo-topo img {
  width: 60% !important;
  max-width: 220px !important;
  height: auto !important;
}


/* Ajuste definitivo: logo 60% do tamanho anterior */
#brandLogo {
  width: 36% !important;
  max-width: 156px !important;
  height: auto !important;
}
.brandHeader img {
  width: 36% !important;
  max-width: 156px !important;
  height: auto !important;
}

  </style>
  <link rel="icon" type="image/png" href="icone.png" />
</head>
<body>
  <div class="wrap">
    
    <div class="brandHeader brandHeaderTop">
      <img id="brandLogo" src="logo-idealize.png" alt="Idealize Decoração" />
    </div>
<h1>Calculadora de Preço de Quadros</h1>

    <div class="card">
      <div class="grid">
        <div class="col-6">
          <label for="w">Largura (cm)</label>
          <input id="w" type="tel" inputmode="numeric" pattern="[0-9., ]*" autocomplete="off" placeholder="Ex.: 60" />
        </div>
        <div class="col-6">
          <label for="h">Altura (cm)</label>
          <input id="h" type="tel" inputmode="numeric" pattern="[0-9., ]*" autocomplete="off" placeholder="Ex.: 90" />
        </div>

        <div class="col-4">
          <label for="linha">Linha</label>
          <select id="linha">
            <option value="B">Básico</option>
            <option value="P">Premium</option>
          </select>
        </div>
        <div class="col-4">
          <label for="vidro">Vidro</label>
          <select id="vidro">
            <option value="SV">Sem vidro</option>
            <option value="CV">Com vidro</option>
          </select>
        </div>
        <div class="col-4">
          <label for="modo">Modo</label>
          <select id="modo">
            <option value="auto">Automático</option>
            <option value="forcar_tabela">Forçar tabela (somente se existir)</option>
            <option value="forcar_formula">Forçar fórmula (somente se não existir na tabela)</option>
          </select>
        </div>

        <div class="col-12">
          <button class="btn" id="calc">Calcular</button>
        </div>

        <div class="col-12">
          <div class="hr"></div>
<div class="row">
            <span class="pill" id="tagTipo">Aguardando cálculo</span>
            <span class="pill" id="tagRegras">Vidro: área até 2,20 m² e menor lado até 1,20 m</span>
            <span class="pill" id="tagArred">Arredondamento: sempre para cima em múltiplos de R$ 5,00</span>
          </div>
          <div class="out" id="outTotal">R$ 0,00</div>
          <div class="resumo" id="resumo" aria-live="polite">
            <div class="rline"><span>Preço do quadro</span><b id="outQuadro">R$ 0,00</b></div>
            <div class="rline"><span>Frete (interno)</span><b id="outFrete">R$ 0,00</b></div>
            <div class="rline total"><span>Total para enviar ao cliente</span><b id="outCliente">R$ 0,00</b></div>
            <div class="stamp" id="outStamp">Cálculo: -</div>
          </div>
          <div class="copyHint">Dica: use o botão abaixo para copiar o orçamento pronto e colar no WhatsApp.</div>
          <div class="hr"></div>
          <button class="btn secondary" id="copy">Copiar orçamento</button>
          <div class="meta" id="meta"></div>
        </div>
      </div>
    </div>

    <div style="height:12px"></div>

    <div class="card">
      <div class="meta">
        <div><b>Regras usadas</b></div>
        <ul>
          <li><b>Lei do vidro</b>: permitido somente se área ≤ 2,20 m² e menor lado ≤ 1,20 m. Se não passar, vidro é bloqueado.</li>
          <li><b>Tabela vence fórmula</b>: se o tamanho existir na tabela e tiver preço preenchido para a configuração, o sistema retorna o valor da tabela (padrão ou não padrão).</li>
          <li><b>Fórmula</b>: só entra quando o tamanho não existir na tabela (ou quando você forçar fórmula). Usa curva baseada apenas nos padrões.</li>
          <li><b>Não fabricamos</b>: se a célula estiver vazia na tabela, essa configuração é bloqueada (ex.: muito grande com vidro).</li>
          <li><b>Preços</b>: sempre arredondados para cima no múltiplo de R$ 5,00.</li>
        </ul>
      </div>
    </div>
  </div>

<script>

  // =========================
  // Detectar ambiente (local vs GitHub Pages)
  // =========================
  const basePath = window.location.pathname.includes('/calcquadros/') ? '/calcquadros/' : './';
  
  // Ajustar caminhos de imagens
  document.getElementById('brandLogo').src = basePath + 'logo-idealize.png';
  document.querySelector('link[rel="icon"]').href = basePath + 'icone.png';

  // =========================
  // CONFIG - Dados de preços embutidos (com fallback para CSV externo)
  // =========================
  let TABELA_PRECOS = {};
  let BETAS = {};
  let dataLoaded = false;

  // Dados padrão embutidos no HTML (fallback)
  const DADOS_PADRAO = {"20x30":{"is_standard":true,"w_cm":20,"h_cm":30,"SV-B":60.0,"CV-B":75.0,"SV-P":70.0,"CV-P":85.0},"30x40":{"is_standard":true,"w_cm":30,"h_cm":40,"SV-B":95.0,"CV-B":120.0,"SV-P":110.0,"CV-P":135.0},"40x40":{"is_standard":true,"w_cm":40,"h_cm":40,"SV-B":125.0,"CV-B":160.0,"SV-P":140.0,"CV-P":175.0},"40x60":{"is_standard":true,"w_cm":40,"h_cm":60,"SV-B":155.0,"CV-B":190.0,"SV-P":175.0,"CV-P":210.0},"50x50":{"is_standard":true,"w_cm":50,"h_cm":50,"SV-B":175.0,"CV-B":210.0,"SV-P":195.0,"CV-P":230.0},"40x80":{"is_standard":true,"w_cm":40,"h_cm":80,"SV-B":190.0,"CV-B":230.0,"SV-P":215.0,"CV-P":255.0},"50x70":{"is_standard":true,"w_cm":50,"h_cm":70,"SV-B":205.0,"CV-B":230.0,"SV-P":230.0,"CV-P":255.0},"60x60":{"is_standard":true,"w_cm":60,"h_cm":60,"SV-B":215.0,"CV-B":255.0,"SV-P":240.0,"CV-P":280.0},"60x80":{"is_standard":true,"w_cm":60,"h_cm":80,"SV-B":255.0,"CV-B":330.0,"SV-P":285.0,"CV-P":360.0},"70x70":{"is_standard":false,"w_cm":70,"h_cm":70,"SV-B":285.0,"CV-B":350.0,"SV-P":315.0,"CV-P":380.0},"50x100":{"is_standard":false,"w_cm":50,"h_cm":100,"SV-B":310.0,"CV-B":430.0,"SV-P":340.0,"CV-P":460.0},"60x90":{"is_standard":true,"w_cm":60,"h_cm":90,"SV-B":280.0,"CV-B":385.0,"SV-P":310.0,"CV-P":415.0},"70x90":{"is_standard":false,"w_cm":70,"h_cm":90,"SV-B":375.0,"CV-B":540.0,"SV-P":415.0,"CV-P":580.0},"80x80":{"is_standard":false,"w_cm":80,"h_cm":80,"SV-B":380.0,"CV-B":530.0,"SV-P":420.0,"CV-P":570.0},"70x100":{"is_standard":true,"w_cm":70,"h_cm":100,"SV-B":410.0,"CV-B":590.0,"SV-P":450.0,"CV-P":630.0},"60x120":{"is_standard":false,"w_cm":60,"h_cm":120,"SV-B":455.0,"CV-B":590.0,"SV-P":495.0,"CV-P":630.0},"90x90":{"is_standard":false,"w_cm":90,"h_cm":90,"SV-B":450.0,"CV-B":650.0,"SV-P":490.0,"CV-P":690.0},"70x130":{"is_standard":false,"w_cm":70,"h_cm":130,"SV-B":560.0,"CV-B":790.0,"SV-P":600.0,"CV-P":830.0},"60x160":{"is_standard":false,"w_cm":60,"h_cm":160,"SV-B":690.0,"CV-B":910.0,"SV-P":740.0,"CV-P":960.0},"80x120":{"is_standard":true,"w_cm":80,"h_cm":120,"SV-B":565.0,"CV-B":795.0,"SV-P":605.0,"CV-P":835.0},"100x100":{"is_standard":true,"w_cm":100,"h_cm":100,"SV-B":570.0,"CV-B":800.0,"SV-P":610.0,"CV-P":840.0},"90x130":{"is_standard":true,"w_cm":90,"h_cm":130,"SV-B":660.0,"CV-B":930.0,"SV-P":710.0,"CV-P":980.0},"100x120":{"is_standard":false,"w_cm":100,"h_cm":120,"SV-B":650.0,"CV-B":990.0,"SV-P":690.0,"CV-P":1040.0},"80x160":{"is_standard":false,"w_cm":80,"h_cm":160,"SV-B":790.0,"CV-B":1050.0,"SV-P":840.0,"CV-P":1100.0},"100x130":{"is_standard":false,"w_cm":100,"h_cm":130,"SV-B":770.0,"CV-B":1090.0,"SV-P":820.0,"CV-P":1140.0},"120x120":{"is_standard":false,"w_cm":120,"h_cm":120,"SV-B":830.0,"CV-B":1350.0,"SV-P":880.0,"CV-P":1400.0},"100x150":{"is_standard":true,"w_cm":100,"h_cm":150,"SV-B":990.0,"CV-B":1390.0,"SV-P":1040.0,"CV-P":1440.0},"90x180":{"is_standard":false,"w_cm":90,"h_cm":180,"SV-B":1020.0,"CV-B":1450.0,"SV-P":1080.0,"CV-P":1510.0},"90x200":{"is_standard":false,"w_cm":90,"h_cm":200,"SV-B":1120.0,"CV-B":1650.0,"SV-P":1180.0,"CV-P":1710.0},"100x200":{"is_standard":true,"w_cm":100,"h_cm":200,"SV-B":1190.0,"CV-B":1790.0,"SV-P":1250.0,"CV-P":1850.0},"120x180":{"is_standard":false,"w_cm":120,"h_cm":180,"SV-B":1550.0,"CV-B":null,"SV-P":1610.0,"CV-P":null},"140x190":{"is_standard":false,"w_cm":140,"h_cm":190,"SV-B":1750.0,"CV-B":null,"SV-P":1820.0,"CV-P":null},"140x200":{"is_standard":false,"w_cm":140,"h_cm":200,"SV-B":1800.0,"CV-B":null,"SV-P":1870.0,"CV-P":null},"140x230":{"is_standard":false,"w_cm":140,"h_cm":229,"SV-B":2200.0,"CV-B":null,"SV-P":2280.0,"CV-P":null}};

  // Função para carregar dados do CSV (tenta, mas usa fallback se falhar)
  async function loadPricingData(csvPath = 'precos.csv') {
    try {
      const response = await fetch(basePath + csvPath);
      if (!response.ok) throw new Error('CSV não encontrado');
      const csvText = await response.text();
      
      // Parse CSV
      const lines = csvText.trim().split('\n');
      const headers = lines[0].split(',');
      
      TABELA_PRECOS = {};
      
      for (let i = 1; i < lines.length; i++) {
        const values = lines[i].split(',');
        if (values.length < 2 || !values[0].trim()) continue;
        
        const tamanho = values[0].trim();
        const isPadrao = values[1].trim() === 'Sim';
        const largura = parseFloat(values[2]);
        const altura = parseFloat(values[3]);
        const svB = values[4].trim() ? parseFloat(values[4]) : null;
        const cvB = values[5].trim() ? parseFloat(values[5]) : null;
        const svP = values[6].trim() ? parseFloat(values[6]) : null;
        const cvP = values[7].trim() ? parseFloat(values[7]) : null;
        
        TABELA_PRECOS[tamanho] = {
          is_standard: isPadrao,
          w_cm: Math.round(largura * 100),
          h_cm: Math.round(altura * 100),
          'SV-B': svB,
          'CV-B': cvB,
          'SV-P': svP,
          'CV-P': cvP
        };
      }
      
      console.log('✓ Dados carregados do CSV externo');
    } catch (error) {
      console.log('ℹ CSV não encontrado, usando dados padrão embutidos');
      TABELA_PRECOS = JSON.parse(JSON.stringify(DADOS_PADRAO));
    }
    
    // Calcular betas baseado nos preços padrão
    calculateBetas();
    dataLoaded = true;
    console.log(`✓ Total de tamanhos: ${Object.keys(TABELA_PRECOS).length}`);
  }

  // Função para calcular betas a partir dos preços padrão
  function calculateBetas() {
    // Extrai dados dos tamanhos padrão para calcular as curvas
    const standardItems = Object.entries(TABELA_PRECOS)
      .filter(([_, item]) => item.is_standard)
      .map(([_, item]) => ({
        w_cm: item.w_cm,
        h_cm: item.h_cm,
        'SV-B': item['SV-B'],
        'CV-B': item['CV-B'],
        'SV-P': item['SV-P'],
        'CV-P': item['CV-P']
      }));
    
    // Calcula regressão linear para cada tipo (SV-B, CV-B, SV-P, CV-P)
    const tipos = ['SV-B', 'CV-B', 'SV-P', 'CV-P'];
    BETAS = {};
    
    tipos.forEach(tipo => {
      const points = standardItems
        .filter(item => item[tipo] !== null)
        .map(item => {
          const wM = item.w_cm / 100;
          const hM = item.h_cm / 100;
          const area = wM * hM;
          const linear = 2 * (wM + hM);
          return { area, linear, price: item[tipo] };
        });
      
      if (points.length >= 3) {
        // Regressão: price = a + b*area + c*linear
        const beta = calculateRegression(points);
        BETAS[tipo] = beta;
      }
    });
  }

  // Função auxiliar para calcular regressão linear múltipla
  function calculateRegression(points) {
    // Usa mínimos quadrados para: price = a + b*area + c*linear
    const n = points.length;
    let sumPrice = 0, sumArea = 0, sumLinear = 0;
    let sumPrice2 = 0, sumArea2 = 0, sumLinear2 = 0;
    let sumPriceArea = 0, sumPriceLinear = 0, sumAreaLinear = 0;
    
    points.forEach(p => {
      sumPrice += p.price;
      sumArea += p.area;
      sumLinear += p.linear;
      sumPrice2 += p.price * p.price;
      sumArea2 += p.area * p.area;
      sumLinear2 += p.linear * p.linear;
      sumPriceArea += p.price * p.area;
      sumPriceLinear += p.price * p.linear;
      sumAreaLinear += p.area * p.linear;
    });
    
    // Matriz de sistema linear 3x3
    const A = [
      [n, sumArea, sumLinear],
      [sumArea, sumArea2, sumAreaLinear],
      [sumLinear, sumAreaLinear, sumLinear2]
    ];
    
    const b = [sumPrice, sumPriceArea, sumPriceLinear];
    
    // Resolve usando eliminação de Gauss
    const solution = solveLinearSystem(A, b);
    return solution || [0, 0, 0];
  }

  // Função para resolver sistema linear 3x3
  function solveLinearSystem(A, b) {
    // Cópia das matrizes para não modificar originais
    const matrix = A.map(row => [...row]);
    const vec = [...b];
    
    // Eliminação de Gauss com pivotamento
    for (let i = 0; i < 3; i++) {
      // Encontra pivô
      let maxRow = i;
      for (let k = i + 1; k < 3; k++) {
        if (Math.abs(matrix[k][i]) > Math.abs(matrix[maxRow][i])) {
          maxRow = k;
        }
      }
      
      // Troca linhas
      [matrix[i], matrix[maxRow]] = [matrix[maxRow], matrix[i]];
      [vec[i], vec[maxRow]] = [vec[maxRow], vec[i]];
      
      // Verifica singularidade
      if (Math.abs(matrix[i][i]) < 1e-10) continue;
      
      // Eliminação
      for (let k = i + 1; k < 3; k++) {
        const factor = matrix[k][i] / matrix[i][i];
        for (let j = i; j < 3; j++) {
          matrix[k][j] -= factor * matrix[i][j];
        }
        vec[k] -= factor * vec[i];
      }
    }
    
    // Substituição reversa
    const x = [0, 0, 0];
    for (let i = 2; i >= 0; i--) {
      x[i] = vec[i];
      for (let j = i + 1; j < 3; j++) {
        x[i] -= matrix[i][j] * x[j];
      }
      if (Math.abs(matrix[i][i]) > 1e-10) {
        x[i] /= matrix[i][i];
      }
    }
    
    return x;
  }

  // Regras do vidro
  const LIMITE_AREA_VIDRO = 2.20; // m²
  const LIMITE_MENOR_LADO_VIDRO = 1.20; // m

  // Taxas para tamanho não padrão (aplicadas somente quando NÃO existir na tabela)
  const TAXA_NAO_PADRAO_POR_AREA = [
    { max: 0.25, valor: 30 },
    { max: 0.50, valor: 40 },
    { max: 1.00, valor: 55 },
    { max: 1.80, valor: 75 },
    { max: Infinity, valor: 110 },
  ];

  // Extra quando for não padrão e com vidro (variável por área)
  const EXTRA_VIDRO_NAO_PADRAO_POR_AREA = [
    { max: 0.50, valor: 25 },
    { max: 1.00, valor: 35 },
    { max: 1.80, valor: 45 },
    { max: Infinity, valor: 55 },
  ];

  // Arredondamento: múltiplos de R$ 5,00 sempre para cima
  const MULT_ARRED = 5;

  // =========================
  // Helpers
  // =========================
  const brl = new Intl.NumberFormat('pt-BR', { style:'currency', currency:'BRL', minimumFractionDigits:2 });

// Marca (para exibir na imagem copiada)
// Fundo do app é escuro, então a versão negativa fica mais legível.
const brandImg = new Image();
brandImg.src = basePath + "logo-idealize.png";
const brandReady = new Promise((resolve) => {
  brandImg.onload = () => resolve(true);
  brandImg.onerror = () => resolve(false);
});


  function sanitizeNumericInput(raw) {
  // Mantém dígitos e separadores básicos. Remove espaços e outros caracteres.
  return String(raw ?? '')
    .trim()
    .replace(/\s+/g, '')
    .replace(/[^0-9.,]/g, '')
    .replace(/(,)(?=.*[,])/g, '') // se houver mais de uma vírgula, mantém apenas a última
    .replace(/(\.)(?=.*[\.])/g, ''); // se houver mais de um ponto, mantém apenas o último
}

function toNumber(v) {
  if (v === null || v === undefined) return NaN;
  const clean = sanitizeNumericInput(v);
  if (!clean) return NaN;
  const s = clean.replace(',', '.');
  const n = Number(s);
  return Number.isFinite(n) ? n : NaN;
}

function keyFromCm(wCm, hCm) {
    const a = Math.min(wCm, hCm);
    const b = Math.max(wCm, hCm);
    return `${a}x${b}`;
  }

  function arredondaParaCimaMultiplo(x, mult) {
    return Math.ceil(x / mult) * mult;
  }

  function vidroPermitido(wM, hM) {
    const area = wM * hM;
    const menor = Math.min(wM, hM);
    return (area <= LIMITE_AREA_VIDRO) && (menor <= LIMITE_MENOR_LADO_VIDRO);
  }

  function taxaNaoPadrao(area) {
    for (const t of TAXA_NAO_PADRAO_POR_AREA) {
      if (area <= t.max) return t.valor;
    }
    return 0;
  }

  function extraVidroNaoPadrao(area) {
    for (const t of EXTRA_VIDRO_NAO_PADRAO_POR_AREA) {
      if (area <= t.max) return t.valor;
    }
    return 0;
  }

// =========================
// Frete interno (mostrado para consultoras, mas o cliente recebe "frete grátis")
// Regras:
// - Sem adicional até 90x130 (cabe em carro convencional): menor lado <= 90 E maior lado <= 130
// - Há adicional quando (menor lado > 90) OU (maior lado > 130)
// - Valor do adicional: R$ 0,00 / R$ 100,00 / R$ 150,00
//   Corte por preço do quadro (sem frete): >= R$ 800,00 => 150; senão => 100
const CORTE_FRETE_150 = 800;

function exigeFreteAdicional(wCm, hCm) {
  const menor = Math.min(wCm, hCm);
  const maior = Math.max(wCm, hCm);
  return (menor > 90) || (maior > 130);
}

function freteInterno(wCm, hCm, precoQuadro) {
  if (!exigeFreteAdicional(wCm, hCm)) return 0;
  return (precoQuadro >= CORTE_FRETE_150) ? 150 : 100;
}

function formatStampBR(dt) {
  const pad = (n) => String(n).padStart(2,'0');
  const d = pad(dt.getDate());
  const m = pad(dt.getMonth()+1);
  const y = dt.getFullYear();
  const hh = pad(dt.getHours());
  const mm = pad(dt.getMinutes());
  return `${d}/${m}/${y} ${hh}:${mm}`;
}

  function calculaPorFormula(area, linear, tipo, linha) {
    const k = `${tipo}-${linha}`; // SV-B, CV-P etc.
    const beta = BETAS[k];
    if (!beta) return NaN;
    const [a,b,c] = beta;
    return a + b*area + c*linear;
  }

  function ehMultiplo(x, mult) {
  return Math.abs(x / mult - Math.round(x / mult)) < 1e-9;
}

function setOut(precoQuadro, frete, totalCliente, tipoTag, metaText, isWarn=false) {
  document.getElementById('outTotal').textContent = brl.format(totalCliente);
  document.getElementById('outQuadro').textContent = brl.format(precoQuadro);
  document.getElementById('outFrete').textContent = brl.format(frete);
  document.getElementById('outCliente').textContent = brl.format(totalCliente);
  const tag = document.getElementById('tagTipo');
  tag.textContent = tipoTag;
  tag.classList.remove('warn', 'good');
  tag.classList.add(isWarn ? 'warn' : 'good');
  document.getElementById('meta').innerHTML = metaText || '';
}

  function bloqueioNaoFabricamos(vidro, linha) {
    return `Não fabricamos este tamanho com <b>${vidro === 'CV' ? 'vidro' : 'sem vidro'}</b> na linha <b>${linha === 'B' ? 'Básico' : 'Premium'}</b>.`;
  }

  // =========================
  // Main
  let lastCalc = null;

  // =========================
  function calcular() {
  if (!dataLoaded) {
    setOut(0, 0, 0, 'Carregando dados...', 'Aguarde o carregamento dos dados de preços.', true);
    return;
  }

  const wEl = document.getElementById('w');
  const hEl = document.getElementById('h');
  const wRaw = wEl.value;
  const hRaw = hEl.value;

  // Sanitiza no campo (remove caracteres inválidos)
  wEl.value = sanitizeNumericInput(wRaw);
  hEl.value = sanitizeNumericInput(hRaw);

  const wCm = toNumber(wRaw);
  const hCm = toNumber(hRaw);

    const linha = document.getElementById('linha').value; // B/P
    const vidro = document.getElementById('vidro').value; // SV/CV
    const modo = document.getElementById('modo').value;

    if (!Number.isFinite(wCm) || !Number.isFinite(hCm) || wCm <= 0 || hCm <= 0) {
  setOut(0, 0, 0, 'Informe as medidas', 'Digite largura e altura em centímetros (somente números).', true);
  return;
}

// Produção trabalha com centímetros inteiros. Se vier decimal, arredonda.
const wCmInt = Math.round(wCm);
const hCmInt = Math.round(hCm);
const houveArred = (wCmInt !== wCm) || (hCmInt !== hCm);

const notaArred = houveArred
  ? `<br><span class="warn">Obs.: medidas arredondadas para <b>${wCmInt}x${hCmInt} cm</b> (cm inteiros).</span>`
  : '';


const wM = wCmInt / 100.0;
const hM = hCmInt / 100.0;

    const area = wM * hM;
    const linear = 2*(wM + hM);

    // Lei do vidro sempre
    if (vidro === 'CV' && !vidroPermitido(wM, hM)) {
      lastCalc = new Date();
      document.getElementById('outStamp').textContent = `Cálculo: ${formatStampBR(lastCalc)}`;
      setOut(0, 0, 0, 'Com vidro indisponível',
  `Este tamanho não pode ser produzido com vidro.<br>` +
  `Área: <b>${area.toFixed(2)} m²</b>. Menor lado: <b>${Math.min(wM,hM).toFixed(2)} m</b>.<br>` +
  `Regra: área até ${LIMITE_AREA_VIDRO.toFixed(2)} m² e menor lado até ${LIMITE_MENOR_LADO_VIDRO.toFixed(2)} m.<br>` +
  `Sugestão: selecione "Sem vidro".` + notaArred, true);

      return;
    }

    const chave = keyFromCm(wCmInt, hCmInt);
    const item = TABELA_PRECOS[chave] || null;
    const col = `${vidro}-${linha}`;


    // Modo: forçar tabela
    if (modo === 'forcar_tabela') {
      if (!item) {
        setOut(0, 0, 0, 'Não existe na tabela', 'Este tamanho não está na tabela (nem padrão, nem não padrão).', true);
        return;
      }
      if (item[col] === null) {
        setOut(0, 0, 0, 'Não fabricamos', bloqueioNaoFabricamos(vidro, linha), true);
        return;
      }
      const p = item[col];
      const frete = freteInterno(wCmInt, hCmInt, p);
      const totalCliente = p + frete;
      lastCalc = new Date();
      document.getElementById('outStamp').textContent = `Cálculo: ${formatStampBR(lastCalc)}`;
const notaMult = !ehMultiplo(p, MULT_ARRED)
  ? `<br><span class="warn">Obs.: este preço na tabela não é múltiplo de R$ ${MULT_ARRED.toFixed(2)}. A calculadora mantém o valor da tabela.</span>`
  : '';
setOut(p, frete, totalCliente, item.is_standard ? 'Tabela (padrão)' : 'Tabela (não padrão)',
  `Tamanho encontrado na tabela: <b>${item.w_cm}x${item.h_cm} cm</b>.<br>` +
  `Configuração: <b>${vidro === 'CV' ? 'Com vidro' : 'Sem vidro'}</b>, linha <b>${linha === 'B' ? 'Básico' : 'Premium'}</b>.` +
  notaMult + notaArred);

      return;
    }

    // Modo: forçar fórmula (só se não existir na tabela)
    if (modo === 'forcar_formula') {
      if (item) {
        setOut(0, 0, 0, 'Existe na tabela', 'Este tamanho já existe na tabela. Para manter preços praticados, use o modo Automático ou Forçar tabela.', true);
        return;
      }
      // cai para fórmula
    }

    // Automático: se existir na tabela e houver preço, retorna
    if (item) {
      if (item[col] === null) {
        setOut(0, 0, 0, 'Não fabricamos', bloqueioNaoFabricamos(vidro, linha), true);
        return;
      }
      const p = item[col];
      const frete = freteInterno(wCmInt, hCmInt, p);
      const totalCliente = p + frete;
      lastCalc = new Date();
      document.getElementById('outStamp').textContent = `Cálculo: ${formatStampBR(lastCalc)}`;
const notaMult = !ehMultiplo(p, MULT_ARRED)
  ? `<br><span class="warn">Obs.: este preço na tabela não é múltiplo de R$ ${MULT_ARRED.toFixed(2)}. A calculadora mantém o valor da tabela.</span>`
  : '';
setOut(p, frete, totalCliente, item.is_standard ? 'Tabela (padrão)' : 'Tabela (não padrão)',
  `Tamanho encontrado na tabela: <b>${item.w_cm}x${item.h_cm} cm</b>.<br>` +
  `Configuração: <b>${vidro === 'CV' ? 'Com vidro' : 'Sem vidro'}</b>, linha <b>${linha === 'B' ? 'Básico' : 'Premium'}</b>.` +
  notaMult + notaArred);

      return;
    }

    // Fórmula: tamanho novo
    let base = calculaPorFormula(area, linear, vidro, linha);
    if (!Number.isFinite(base)) {
      setOut(0, 0, 0, 'Sem fórmula', 'Não foi possível calcular este preço. Verifique a configuração.', true);
      return;
    }

    const taxa = taxaNaoPadrao(area);
    const extraVidro = (vidro === 'CV') ? extraVidroNaoPadrao(area) : 0;
    let total = base + taxa + extraVidro;

    total = arredondaParaCimaMultiplo(total, MULT_ARRED);
    const precoQuadro = total;
    const frete = freteInterno(wCmInt, hCmInt, precoQuadro);
    const totalCliente = precoQuadro + frete;
    lastCalc = new Date();
    document.getElementById('outStamp').textContent = `Cálculo: ${formatStampBR(lastCalc)}`;

    const detalheTaxa = (taxa > 0 || extraVidro > 0)
      ? `Taxa não padrão: <b>${brl.format(taxa)}</b>${vidro === 'CV' ? ` + extra vidro: <b>${brl.format(extraVidro)}</b>` : ''}.`
      : 'Sem taxa de não padrão.';

    setOut(precoQuadro, frete, totalCliente, 'Novo (fórmula)',
      `Tamanho novo (não existe na tabela). Cálculo por fórmula (área e linear) + taxas.<br>` +
      `Área: <b>${area.toFixed(2)} m²</b>. Linear: <b>${linear.toFixed(2)} m</b>.<br>` +
      `Configuração: <b>${vidro === 'CV' ? 'Com vidro' : 'Sem vidro'}</b>, linha <b>${linha === 'B' ? 'Básico' : 'Premium'}</b>.<br>` +
      `${detalheTaxa}<br>` +
      `Arredondamento: sempre para cima no múltiplo de R$ 5,00.` + notaArred);
  }

  document.getElementById('calc').addEventListener('click', calcular);

  // Logo no topo do orçamento
  const brandLogoEl = document.getElementById('brandLogo');
  // Enter calcula
['w','h'].forEach(id => {
  document.getElementById(id).addEventListener('keydown', (e) => {
    if (e.key === 'Enter') calcular();
  });
  // Ao sair do campo, sanitiza e recalcula
  document.getElementById(id).addEventListener('blur', () => calcular());
});

// Mudou opção: recalcula
['linha','vidro','modo'].forEach(id => {
  document.getElementById(id).addEventListener('change', () => calcular());
});

// =========================
// Copiar orçamento (imagem com carimbo de data/hora, com fallback para texto)
// =========================
function buildOrcamentoText(data) {
  const linhas = [
    `*ORÇAMENTO IDEALIZE*`,
    `Tamanho: ${data.wCm}x${data.hCm} cm`,
    `Linha: ${data.linhaTxt} | ${data.vidroTxt}`,
    ``,
    `Quadro: ${brl.format(data.precoQuadro)}`,
    `Frete: ${brl.format(data.frete)}`,
    `Total: ${brl.format(data.totalCliente)}`,
    ``,
    `Cálculo: ${data.stamp}`
  ];
  return linhas.join('\n');
}

async function copyText(txt) {
  await navigator.clipboard.writeText(txt);
}

async function drawOrcamentoToCanvas(data) {
  // Canvas em pixels (alta qualidade). Ajuste de escala para telas retina.
  const dpr = Math.max(1, Math.floor(window.devicePixelRatio || 1));
  const width = 1000;
  const padding = 44;
  const lineH = 44;
  const sections = 10;
  const height = padding*2 + lineH*sections + 30;

  const canvas = document.createElement('canvas');
  canvas.width = width * dpr;
  canvas.height = height * dpr;
  canvas.style.width = width + 'px';
  canvas.style.height = height + 'px';
  const ctx = canvas.getContext('2d');
  ctx.scale(dpr, dpr);

  // Fundo
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0,0,width,height);

  // Borda
  ctx.strokeStyle = 'rgba(0,0,0,.12)';
  ctx.lineWidth = 2;
  ctx.strokeRect(18,18,width-36,height-36);

  // Logo no topo (centralizado) + título
  let yTop = padding;

  const hasBrand = await brandReady;
  if (hasBrand) {
    const maxW = 300;
    const w = Math.min(maxW, brandImg.width);
    const scale = w / brandImg.width;
    const h = brandImg.height * scale;

    const x = (width - w) / 2;
    const y = 26;
    ctx.drawImage(brandImg, x, y, w, h);

    yTop = y + h + 28;
  } else {
    yTop = padding;
  }

  ctx.fillStyle = '#0b0f14';
  ctx.font = '800 34px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText('ORÇAMENTO', padding, yTop);

  ctx.fillStyle = 'rgba(11,15,20,.75)';
  ctx.font = '600 20px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText('Idealize Decoração', padding, yTop + 30);

  // Linhas
  let y = yTop + 64;
  ctx.fillStyle = '#0b0f14';
  ctx.font = '600 22px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText(`Tamanho: ${data.wCm} x ${data.hCm} cm`, padding, y); y += lineH;
  ctx.fillText(`Linha: ${data.linhaTxt} | ${data.vidroTxt}`, padding, y); y += lineH;

  // separador
  y += 8;
  ctx.strokeStyle = 'rgba(0,0,0,.10)';
  ctx.lineWidth = 2;
  ctx.beginPath(); ctx.moveTo(padding, y); ctx.lineTo(width-padding, y); ctx.stroke();
  y += 34;

  // Valores
  const labelX = padding;
  const valueX = width - padding;
  const drawRow = (label, value, bold=False) => {
    ctx.fillStyle = 'rgba(11,15,20,.75)';
    ctx.font = (bold ? '800 24px ' : '700 22px ') + 'system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.textAlign = 'left';
    ctx.fillText(label, labelX, y);
    ctx.textAlign = 'right';
    ctx.fillStyle = '#0b0f14';
    ctx.font = (bold ? '900 28px ' : '800 24px ') + 'system-ui, -apple-system, Segoe UI, Roboto, Arial';
    ctx.fillText(value, valueX, y);
    y += lineH;
  };

  drawRow('Quadro', brl.format(data.precoQuadro));
  drawRow('Frete', brl.format(data.frete));
  y += 6;
  drawRow('TOTAL', brl.format(data.totalCliente), True);

  // Stamp no rodapé central
  ctx.textAlign = 'center';
  ctx.fillStyle = 'rgba(11,15,20,.65)';
  ctx.font = '700 18px system-ui, -apple-system, Segoe UI, Roboto, Arial';
  ctx.fillText(`Cálculo: ${data.stamp}`, width/2, height - 40);

  return canvas;
}

async function copyCanvasImage(canvas) {
  if (!navigator.clipboard || !window.ClipboardItem) throw new Error('ClipboardItem indisponível');
  const blob = await new Promise((resolve) => canvas.toBlob(resolve, 'image/png'));
  if (!blob) throw new Error('Falha ao gerar imagem');
  await navigator.clipboard.write([ new ClipboardItem({ 'image/png': blob }) ]);
}

document.getElementById('copy').addEventListener('click', async () => {
  // Se ainda não calculou, força cálculo.
  calcular();

  const wCm = Math.round(toNumber(document.getElementById('w').value));
  const hCm = Math.round(toNumber(document.getElementById('h').value));
  const linha = document.getElementById('linha').value;
  const vidro = document.getElementById('vidro').value;

  const precoQuadro = Number(String(document.getElementById('outQuadro').textContent).replace(/[^0-9,]/g,'').replace(',','.')) || 0;
  const frete = Number(String(document.getElementById('outFrete').textContent).replace(/[^0-9,]/g,'').replace(',','.')) || 0;
  const totalCliente = Number(String(document.getElementById('outCliente').textContent).replace(/[^0-9,]/g,'').replace(',','.')) || 0;

  const stamp = (lastCalc instanceof Date) ? formatStampBR(lastCalc) : formatStampBR(new Date());
  const data = {
    wCm, hCm,
    linhaTxt: (linha === 'B') ? 'Básico' : 'Premium',
    vidroTxt: (vidro === 'CV') ? 'Com vidro' : 'Sem vidro',
    precoQuadro, frete, totalCliente, stamp
  };

  try {
    const canvas = await drawOrcamentoToCanvas(data);
    await copyCanvasImage(canvas);
    document.getElementById('meta').innerHTML = `<span class="good">Orçamento copiado como imagem. Agora é só colar no WhatsApp.</span>`;
  } catch (e) {
    // Fallback: texto
    try {
      await copyText(buildOrcamentoText(data));
      document.getElementById('meta').innerHTML = `<span class="good">Orçamento copiado como texto. Agora é só colar no WhatsApp.</span>`;
    } catch (e2) {
      document.getElementById('meta').innerHTML = `<span class="warn">Não consegui copiar automaticamente. Seu navegador pode estar bloqueando a área de transferência.</span>`;
    }
  }
});

// Carrega dados ao iniciar
window.addEventListener('DOMContentLoaded', () => {
  loadPricingData('precos.csv');
});

// Fallback se o documento já estiver carregado
if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', () => {
    loadPricingData('precos.csv');
  });
} else {
  loadPricingData('precos.csv');
}

</script>
</body>
</html>
